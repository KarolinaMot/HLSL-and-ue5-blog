<!DOCTYPE html>
<html lang="en-US">

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,maximum-scale=2">
    <link rel="stylesheet" href="assets/css/style.css">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Creating shaders in UE5 with HLSL</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="HLSL-and-ue5-blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A blog post about creating post processing effects using HLSL in UE5" />
<meta property="og:description" content="A blog post about creating post processing effects using HLSL in UE5" />
<link rel="canonical" href="http://localhost:4000/Index.html" />
<meta property="og:url" content="http://localhost:4000/Index.html" />
<meta property="og:site_name" content="HLSL-and-ue5-blog" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="HLSL-and-ue5-blog" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"A blog post about creating post processing effects using HLSL in UE5","headline":"HLSL-and-ue5-blog","url":"http://localhost:4000/Index.html"}</script>



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->

  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <img src="assets/images/Buas.png" height="40px">
          <h1 id="project_title">Creating shaders in UE5 with HLSL</h1>
          <h2 id="project_tagline">A blog post about creating post processing effects using HLSL in UE5.</h2>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer" >
      <section id="main_content" class="inner">
          
<h2 id="introduction">Introduction</h2>

<p>While the material graph in UE5 is quite complete, sometimes using HLSL is a better alternative. For example, not only are for loops nowhere to be found in the material graph, it can also get tedious and messy very fast as the complexity of a shader increases.</p>

<p>In this post, I will showcase some ways to create shaders using HLSL and explain their pros and cons. Rest assured, none of these will require you to tackle the tedious task of building UE5 from source.</p>

<h2 id="the-custom-node">The custom node</h2>

<p>The easiest and fastest way to create shaders with HLSL in UE5 is by using the custom node in the material graph.</p>

<p>Let’s create a simple edge detection shader using the scene depth buffer. If you’re unfamiliar with using a Sobel matrix for this purpose, I recommend watching <a href="https://www.youtube.com/watch?v=PXLgkxRizPI&amp;t=1158s">this video</a>, which explains the basics.</p>

<p>First, we’ll write the shader code directly in the node’s HLSL input:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float2</span> <span class="n">pixelSize</span> <span class="o">=</span> <span class="n">LineThickness</span> <span class="o">/</span> <span class="n">ScreenSize</span><span class="p">;</span>
<span class="n">float2</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span>
                         <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                         <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="n">f</span><span class="p">)};</span>
 
<span class="n">float2</span> <span class="n">gradients</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">);</span>

 <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">i</span><span class="o">%</span><span class="mi">3</span><span class="p">;</span>

     <span class="kt">float</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span><span class="n">pixelSize</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">offsetY</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span><span class="n">pixelSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

     <span class="n">float2</span> <span class="n">offsetUV</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">Uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">offsetX</span><span class="p">,</span> <span class="n">Uv</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">offsetY</span><span class="p">);</span>
     
     <span class="n">float4</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="n">SceneTextureLookup</span><span class="p">(</span><span class="n">offsetUV</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

     <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">SceneTexture</span><span class="p">.</span><span class="n">r</span> <span class="o">/</span> <span class="n">DepthPrecision</span><span class="p">);</span>
      
     <span class="n">gradients</span><span class="o">+=</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">depth</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="n">gradients</span> <span class="o">*=</span> <span class="n">LineThickness</span><span class="p">;</span>

 <span class="k">return</span> <span class="nf">length</span><span class="p">(</span><span class="n">gradients</span><span class="p">);</span>
</code></pre></div></div>

<p>The SceneTextureLookup(uv, texIndex, …) function samples the scene depth texture, and here, the index is set to 1 based on the “Scene Texture Id” in the SceneTexture node.</p>

<p><img src="assets/images/SceneTextureIndices.png" alt="alt text" title="Title" /></p>

<p>The node requires a few inputs—UV, EdgeThickness, ScreenSize, DepthBias, and DepthPrecision—which can be added through the node’s details window:</p>

<p><img src="assets/images/CustomNodeInputs.png" alt="alt text" title="Title" /></p>

<p>We also add an input named “Color” to plug in a SceneTexture node. It doesn’t need to be used or referenced directly; it’s there so that we can use <code class="language-plaintext highlighter-rouge">SceneTextureLookup()</code>.</p>

<p>Next, set the return type of the node snippet to float in the node’s details.</p>

<p><img src="assets/images/CustomNodeReturnType.png" alt="alt text" title="Title" /></p>

<p>Once everything is connected, this is the result</p>

<p><img src="assets/images/CustomNodeBP.png" alt="alt text" title="Title" />
<img src="assets/images/Outlines.png" alt="alt text" title="Title" /></p>

<h2 id="using-external-shaders-with-the-custom-node">Using external shaders with the custom node</h2>

<p>If you’re familiar with the custom node, you may have noticed an input for include paths:</p>

<p><img src="assets/images/IncludeFilePaths.png" alt="alt text" title="Title" /></p>

<p>Include paths become useful when shader code grows in complexity, and you’d prefer to work in a text editor. UE5 does not expect external HLSL files, so using them requires a bit of setup.</p>

<h3 id="setup">Setup</h3>

<p>The default shader path is in the engine folder, but if you’d like to keep your shaders under version control, we’ll set up an alternative path in the game module. This requires some C++ knowledge and Visual Studio.</p>

<ol>
  <li>Create a Shaders folder in your project’s root directory.</li>
  <li>Generate a solution file by right-clicking the .uproject file and selecting “Generate Visual Studio Project Files.”</li>
  <li>Open the project in Visual Studio.</li>
</ol>

<p>In the <code class="language-plaintext highlighter-rouge">Source/ProjectName</code> folder, update <code class="language-plaintext highlighter-rouge">ProjectName.Build.cs</code> to add <code class="language-plaintext highlighter-rouge">RenderCore</code> as a public dependency module:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"Core"</span><span class="p">,</span> <span class="s">"RenderCore"</span><span class="p">,</span> <span class="s">"CoreUObject"</span><span class="p">,</span> <span class="s">"Engine"</span><span class="p">,</span> <span class="s">"InputCore"</span><span class="p">});</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">ProjectName.h</code>, create a game module class:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//ProjectName.h</span>
<span class="cp">#include "CoreMinimal.h"
</span>
<span class="k">class</span> <span class="nc">FProjectModule</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IModuleInterface</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">StartupModule</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">ShutdownModule</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In ProjectName.cpp, define StartupModule() to add the Shaders folder as a secondary directory:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FString</span> <span class="n">ShaderDirectory</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span><span class="n">FPaths</span><span class="o">::</span><span class="n">ProjectDir</span><span class="p">(),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Shaders"</span><span class="p">));</span>
<span class="n">AddShaderSourceDirectoryMapping</span><span class="p">(</span><span class="s">"/Project"</span><span class="p">,</span> <span class="n">ShaderDirectory</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, override the primary game module with <code class="language-plaintext highlighter-rouge">IMPLEMENT_PRIMARY_GAME_MODULE(FProjectModule, ProjectName, ModuleRulesName);</code></p>

<p>These is the final file:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Copyright Epic Games, Inc. All Rights Reserved.</span>

<span class="cp">#include "Prototypes.h"
#include "Modules/ModuleManager.h"
#include "Interfaces/IPluginManager.h"
#include "Logging/LogMacros.h"
#include "Misc/Paths.h" // include this!
</span>
<span class="kt">void</span> <span class="n">FPrototypesModule</span><span class="o">::</span><span class="n">StartupModule</span><span class="p">()</span>
<span class="p">{</span>
<span class="n">FString</span> <span class="n">ShaderDirectory</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span><span class="n">FPaths</span><span class="o">::</span><span class="n">ProjectDir</span><span class="p">(),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Shaders"</span><span class="p">));</span>
<span class="n">AddShaderSourceDirectoryMapping</span><span class="p">(</span><span class="s">"/Project"</span><span class="p">,</span> <span class="n">ShaderDirectory</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">FPrototypesModule</span><span class="o">::</span><span class="n">ShutdownModule</span><span class="p">(){}</span>

<span class="n">IMPLEMENT_PRIMARY_GAME_MODULE</span><span class="p">(</span><span class="n">FPrototypesModule</span><span class="p">,</span> <span class="n">Prototypes</span><span class="p">,</span> <span class="s">"Prototypes"</span><span class="p">);</span>

</code></pre></div></div>

<p>Once this is all done, you can press F5 to launch UE5.</p>

<h3 id="using-it">Using it</h3>

<p>To expand the previous shader, let’s say we want to apply a noise texture along the edges of the objects.</p>

<p>Shaders in UE5 have to be created with the .ush or .usf extensions, so let’s create a new file in the “Shaders” folder we created and call it “EdgeDetection.ush”.</p>

<p>Here we can paste this code:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">DetectEdges</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">GetNormal</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">float4</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="n">SceneTextureLookup</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">SceneTexture</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">GetDepth</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthPrecision</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">float4</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="n">SceneTextureLookup</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">saturate</span><span class="p">(</span><span class="n">SceneTexture</span><span class="p">.</span><span class="n">r</span> <span class="o">/</span> <span class="n">depthPrecision</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">float3</span> <span class="n">GetColor</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">float4</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="n">SceneTextureLookup</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">SceneTexture</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">float</span> <span class="n">IsEdge</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="n">float3</span> <span class="n">color</span><span class="p">,</span> <span class="kt">float</span> <span class="n">EdgeThickness</span><span class="p">,</span> <span class="n">float2</span> <span class="n">screenSize</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthBias</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthPrecision</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="n">pixelSize</span> <span class="o">=</span> <span class="n">EdgeThickness</span> <span class="o">/</span> <span class="n">screenSize</span><span class="p">;</span>
        <span class="n">float2</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span>
                                <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>
                                <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.5</span><span class="n">f</span><span class="p">)};</span>
        
        <span class="n">float2</span> <span class="n">gradients</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="mi">3</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">i</span><span class="o">%</span><span class="mi">3</span><span class="p">;</span>

            <span class="kt">float</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span><span class="n">pixelSize</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">offsetY</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span><span class="n">pixelSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>

            <span class="n">float2</span> <span class="n">offsetUV</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">offsetX</span><span class="p">,</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">offsetY</span><span class="p">);</span>
            
            <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">GetDepth</span><span class="p">(</span><span class="n">offsetUV</span><span class="p">,</span> <span class="n">depthPrecision</span><span class="p">);</span>
            <span class="n">gradients</span><span class="o">+=</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">depth</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">gradients</span> <span class="o">*=</span> <span class="n">EdgeThickness</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">gradients</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="n">float3</span> <span class="n">DetectEdge</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="n">float3</span> <span class="n">color</span><span class="p">,</span> <span class="kt">float</span> <span class="n">EdgeThickness</span><span class="p">,</span> <span class="n">float2</span> <span class="n">screenSize</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthBias</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthPrecision</span><span class="p">,</span> <span class="n">float3</span> <span class="n">noise</span><span class="p">,</span> <span class="kt">float</span> <span class="n">noiseStrength</span><span class="p">,</span> <span class="n">float3</span> <span class="n">tendrilColor</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">DebugLines</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">float2</span> <span class="n">pixelSize</span> <span class="o">=</span> <span class="n">EdgeThickness</span> <span class="o">/</span> <span class="n">screenSize</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">IsEdge</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">EdgeThickness</span><span class="p">,</span> <span class="n">screenSize</span><span class="p">,</span> <span class="n">depthBias</span><span class="p">,</span> <span class="n">depthPrecision</span><span class="p">);</span>
        <span class="n">float3</span> <span class="n">sceneColor</span> <span class="o">=</span>  <span class="n">GetColor</span><span class="p">(</span><span class="n">uv</span><span class="p">);</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.</span><span class="n">f</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">DebugLines</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">tendrilColor</span> <span class="o">*</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="n">depthBias</span> <span class="o">?</span> <span class="n">tendrilColor</span> <span class="o">*</span> <span class="n">edge</span> <span class="o">:</span> <span class="n">float3</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">float3</span> <span class="n">result</span> <span class="o">=</span> <span class="n">sceneColor</span> <span class="o">+</span> <span class="n">tendrilColor</span> <span class="o">*</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">noiseStrength</span> <span class="o">*</span> <span class="n">edge</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">edge</span> <span class="o">&gt;</span> <span class="n">depthBias</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="n">sceneColor</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The custom node inserts your code in a function called <code class="language-plaintext highlighter-rouge">MaterialFloat3 CustomExpression0()</code>. You can check this by going to Window-&gt;ShaderCode-&gt;HLSL Code, which shows you the generated shader for your material graph. For this reason, when you want to encapsulate something in a function, you must do so by using structs.</p>

<p>Now to finally to use this shader, you plug everything in, you add the include path to the right slot, in this case “/Project/EdgeDetection.ush” and call the function in the node like this:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DetectEdges</span> <span class="n">detect</span><span class="p">;</span>
<span class="k">return</span> <span class="n">detect</span><span class="p">.</span><span class="n">DetectEdge</span><span class="p">(</span><span class="n">Uv</span><span class="p">,</span> <span class="n">Color</span><span class="p">,</span> <span class="n">LineThickness</span><span class="p">,</span> <span class="n">ScreenSize</span><span class="p">,</span> <span class="n">DepthBias</span><span class="p">,</span> <span class="n">DepthPrecision</span><span class="p">,</span> <span class="n">Noise</span><span class="p">,</span> <span class="n">NoiseStrength</span><span class="p">,</span> <span class="n">TendrilColor</span><span class="p">,</span> <span class="n">DebugLines</span><span class="p">);</span>
</code></pre></div></div>

<p>This is the final result!</p>

<p><img src="assets/images/Aura.gif" alt="alt text" title="Title" /></p>

<h2 id="global-shaders-and-sceneviewextension">Global Shaders and SceneViewExtension</h2>

<table>
  <tbody>
    <tr>
      <td>Note: This approach requires familiarity with C++ and graphics programming.</td>
    </tr>
  </tbody>
</table>

<p>While custom nodes work well for simpler shaders, more complex effects that require multiple rendering passes are best achieved using SceneViewExtensions and Global Shaders. Here’s an overview of what these two features do and how they enable advanced rendering effects in UE5.</p>

<h3 id="why-use-sceneviewextensions-and-global-shaders">Why Use SceneViewExtensions and Global Shaders?</h3>

<p><em>SceneViewExtension</em> allows you to inject custom render passes without modifying the Unreal Engine source code. This means you can add custom post-processing steps and advanced effects to the UE5 rendering pipeline.</p>

<p><em>Global Shaders</em> are shaders created with C++ that operate on fixed geometry and don’t need to interact with materials or mesh data. This makes them ideal for post-processing effects and non-mesh-based shaders, like screen-space effects. Unlike PostProcessingShaders, Global Shaders don’t need to tie into the post-processing pipeline, so they’re more flexible and can be added directly to the rendering sequence without modifying the source code.</p>

<p>For a deeper dive into shader types in Unreal Engine, check out <a href="https://logins.github.io/graphics/2021/03/31/UE4ShadersIntroduction.html">blog post</a>.</p>

<h3 id="the-game-module">The game module</h3>

<p>To add Global Shaders in UE5, you need to create a custom game module separate from the primary one. This is because shaders need to be compiled at a certain point, and by the time the primary game module is initialized – it is too late. Here’s a step-by-step guide for setting up this custom module.</p>

<h4 id="step-1-create-the-module-folder-structure">Step 1: Create the Module Folder Structure</h4>

<ol>
  <li>Go to ProjectName/Source.</li>
  <li>Create a new folder for the module (e.g., AuraShaderModule).</li>
  <li>Inside this folder, create three subfolders:
    <ul>
      <li>Public: for header files</li>
      <li>Private: for implementation files</li>
      <li>Shaders: for shader files</li>
    </ul>
  </li>
  <li>Create these files:
    <ul>
      <li><em>Root Module Folder</em>: <code class="language-plaintext highlighter-rouge">AuraShaderModule.build.cs</code></li>
      <li><em>Public</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">AuraShaderModule.h</code></li>
          <li><code class="language-plaintext highlighter-rouge">CustomViewExtension.h</code></li>
          <li><code class="language-plaintext highlighter-rouge">OutlineShader.h</code></li>
        </ul>
      </li>
      <li><em>Private</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">AuraShaderModule.cpp</code></li>
          <li><code class="language-plaintext highlighter-rouge">CustomViewExtension.cpp</code></li>
          <li><code class="language-plaintext highlighter-rouge">OutlineShader.cpp</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h4 id="step-2-define-the-module-class">Step 2: Define the Module Class</h4>

<p>In AuraShaderModule.h, define the module class:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Public/AuraShaderModule.h</span>
<span class="cp">#pragma once
#include "CoreMinimal.h"
#include "Modules/ModuleManager.h"
</span>
<span class="k">class</span> <span class="nc">FAuraShaderModule</span><span class="o">:</span> <span class="k">public</span> <span class="n">IModuleInterface</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">StartupModule</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>In AuraShaderModule.cpp, implement StartupModule() to set up the shader directory:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Private/AuraShaderModule.cpp</span>
<span class="cp">#include "CustomModule.h"
</span>
<span class="kt">void</span> <span class="n">FAuraShaderModule</span><span class="o">::</span><span class="n">StartupModule</span><span class="p">()</span> <span class="p">{</span>
<span class="n">FString</span> <span class="n">BaseDir</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span><span class="n">FPaths</span><span class="o">::</span><span class="n">GameSourceDir</span><span class="p">(),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"AuraShaderModule"</span><span class="p">));</span>
<span class="n">FString</span> <span class="n">ModuleShaderDir</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span><span class="n">BaseDir</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Shaders"</span><span class="p">));</span>
<span class="n">AddShaderSourceDirectoryMapping</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"/AuraShaderModule"</span><span class="p">),</span> <span class="n">ModuleShaderDir</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">IMPLEMENT_MODULE</span><span class="p">(</span><span class="n">FAuraShaderModule</span><span class="p">,</span> <span class="n">AuraShaderModule</span><span class="p">);</span>
</code></pre></div></div>

<p>Here:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AddShaderSourceDirectoryMapping</code> adds a path to the module’s Shaders folder, so UE5 can find the shaders.</li>
  <li><code class="language-plaintext highlighter-rouge">IMPLEMENT_MODULE</code> registers the module with the engine.</li>
</ul>

<h4 id="step-3-configure-build-rules">Step 3: Configure Build Rules</h4>

<p>In <code class="language-plaintext highlighter-rouge">AuraShaderModule.build.cs</code>, specify module dependencies and include paths:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// AuraShaderModule.build.cs</span>
<span class="k">using</span> <span class="n">UnrealBuildTool</span><span class="p">;</span>
<span class="k">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">;</span>
<span class="k">using</span> <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">;</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">AuraShaderModule</span> <span class="o">:</span> <span class="n">ModuleRules</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">AuraShaderModule</span> <span class="p">(</span><span class="n">ReadOnlyTargetRules</span> <span class="n">Target</span><span class="p">)</span> <span class="o">:</span> <span class="n">base</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PCHUsage</span> <span class="o">=</span> <span class="n">PCHUsageMode</span><span class="p">.</span><span class="n">UseExplicitOrSharedPCHs</span><span class="p">;</span>

        <span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="n">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"Core"</span><span class="p">,</span> <span class="s">"CoreUObject"</span><span class="p">,</span> <span class="s">"Engine"</span><span class="p">,</span> <span class="s">"Renderer"</span><span class="p">,</span> <span class="s">"RenderCore"</span><span class="p">,</span> <span class="s">"RHI"</span> <span class="p">});</span>
        <span class="n">string</span> <span class="n">EnginePath</span> <span class="o">=</span> <span class="n">Path</span><span class="p">.</span><span class="n">GetFullPath</span><span class="p">(</span><span class="n">Target</span><span class="p">.</span><span class="n">RelativeEnginePath</span><span class="p">);</span>
        <span class="n">PublicIncludePaths</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">EnginePath</span> <span class="o">+</span> <span class="s">"Source/Runtime/Renderer/Private"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here we define the public dependencies of the module as in previous examples. We also add <code class="language-plaintext highlighter-rouge">Source/Runtime/Renderer/Private</code> to the include paths, as we will be referencing some private classes.</p>

<h4 id="step-4--add-the-module-to-the-project">Step 4:  Add the Module to the Project</h4>

<p>Finally, we need to actually add the module to the project. For starters let’s add our custom module to the <code class="language-plaintext highlighter-rouge">PublicDependencyModuleNames</code> of our primary module. This can be found under  <code class="language-plaintext highlighter-rouge">Source/ProjectName/AuraShaderModule.Build.cs</code>.</p>

<ol>
  <li>Primary Module’s Build.cs: Add your custom module to the primary module’s dependencies by updating <code class="language-plaintext highlighter-rouge">ProjectName.Build.cs</code>:</li>
</ol>

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AuraShaderModule.Build.cs</span>
<span class="c1">// Copyright Epic Games, Inc. All Rights Reserved.</span>
<span class="k">using</span> <span class="nn">UnrealBuildTool</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Prototypes</span> <span class="p">:</span> <span class="n">ModuleRules</span>
<span class="p">{</span>
<span class="k">public</span> <span class="nf">Prototypes</span><span class="p">(</span><span class="n">ReadOnlyTargetRules</span> <span class="n">Target</span><span class="p">)</span> <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">Target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PCHUsage</span> <span class="p">=</span> <span class="n">PCHUsageMode</span><span class="p">.</span><span class="n">UseExplicitOrSharedPCHs</span><span class="p">;</span>

    <span class="n">PublicDependencyModuleNames</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"Core"</span><span class="p">,</span> <span class="s">"RenderCore"</span><span class="p">,</span> <span class="s">"CoreUObject"</span><span class="p">,</span> <span class="s">"Engine"</span><span class="p">,</span> <span class="s">"InputCore"</span><span class="p">,</span> <span class="s">"AuraShaderModule"</span> <span class="p">});</span>

    <span class="n">PrivateDependencyModuleNames</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span>  <span class="p">});</span>
    <span class="n">PublicIncludePaths</span><span class="p">.</span><span class="nf">AddRange</span><span class="p">(</span><span class="k">new</span> <span class="kt">string</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"D:\\GITHUB\\Prototypes"</span> <span class="p">});</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>UProject File: Open the <code class="language-plaintext highlighter-rouge">.uproject</code> file in a text editor and add <code class="language-plaintext highlighter-rouge">AuraShaderModule</code> with <code class="language-plaintext highlighter-rouge">LoadingPhase</code> set to <code class="language-plaintext highlighter-rouge">PostConfigInit</code>:</li>
</ol>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"Modules"</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s">"Name"</span><span class="o">:</span> <span class="s">"Prototypes"</span><span class="p">,</span>
        <span class="s">"Type"</span><span class="o">:</span> <span class="s">"Runtime"</span><span class="p">,</span>
        <span class="s">"LoadingPhase"</span><span class="o">:</span> <span class="s">"Default"</span><span class="p">,</span>
        <span class="s">"AdditionalDependencies"</span><span class="o">:</span> <span class="p">[</span>
            <span class="s">"Engine"</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s">"Name"</span><span class="o">:</span> <span class="s">"AuraShaderModule"</span><span class="p">,</span>
        <span class="s">"Type"</span><span class="o">:</span> <span class="s">"Runtime"</span><span class="p">,</span>
        <span class="s">"LoadingPhase"</span><span class="o">:</span> <span class="s">"PostConfigInit"</span>
    <span class="p">}</span>
<span class="p">],</span>
</code></pre></div></div>

<p>Once this is all done, you can right click the .uproject file and click on <code class="language-plaintext highlighter-rouge">Generate Visual Studio Project Files</code>.
With these steps completed, your custom game module is ready, and UE5 should recognize and compile shaders within it on launch.</p>

<h3 id="defining-and-implementing-a-global-shader">Defining and implementing a Global Shader</h3>

<p>Now let’s get to the fun part - defining a global shader. Let’s start with <code class="language-plaintext highlighter-rouge">AuraShaderModule/Private/OutlineShader.h</code> and define the input structure for our shaders. These are the same ones as we used in the custom node chapter.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BEGIN_SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FOutlineShaderParameters</span><span class="p">,</span> <span class="p">)</span>
<span class="n">SHADER_PARAMETER_SAMPLER</span><span class="p">(</span><span class="n">SamplerState</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">SceneColor</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">SceneDepth</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER_RDG_TEXTURE</span><span class="p">(</span><span class="n">Texture2D</span><span class="p">,</span> <span class="n">Noise</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="n">FLinearColor</span><span class="p">,</span> <span class="n">LineColor</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">EdgeThickness</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">EdgeIntensity</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">DepthBias</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">Time</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">MovementSpeed</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">NoiseSize</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER</span><span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">NoiseStrength</span><span class="p">)</span>
<span class="n">SHADER_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FScreenPassTextureViewportParameters</span><span class="p">,</span> <span class="n">ViewParams</span><span class="p">)</span>
<span class="n">RENDER_TARGET_BINDING_SLOTS</span><span class="p">()</span>
<span class="n">END_SHADER_PARAMETER_STRUCT</span><span class="p">()</span>
</code></pre></div></div>

<p>These Unreal macros might seem scary, but once you read into it you’ll realize all it does is define a structure using macros.
Next let’s define the shader class.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AuraShaderModule/Public/OutlineShader.h</span>
<span class="k">class</span> <span class="nc">FOutlineShaderPS</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FGlobalShader</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">DECLARE_EXPORTED_SHADER_TYPE</span><span class="p">(</span><span class="n">FOutlineShaderPS</span><span class="p">,</span> <span class="n">Global</span><span class="p">,);</span>
<span class="k">using</span> <span class="n">FParameters</span> <span class="o">=</span> <span class="n">FOutlineShaderParameters</span><span class="p">;</span>
<span class="n">SHADER_USE_PARAMETER_STRUCT</span><span class="p">(</span><span class="n">FOutlineShaderPS</span><span class="p">,</span> <span class="n">FGlobalShader</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>First we declare the shader with <code class="language-plaintext highlighter-rouge">DECLARE_EXPORTED_SHADER_TYPE</code> and then we use an alias for <code class="language-plaintext highlighter-rouge">FOutlineShaderParameters</code> so the next macro, <code class="language-plaintext highlighter-rouge">SHADER_USE_PARAMETER_STRUCT</code> binds the struct to this shader.</p>

<p>Finally in the .cpp file, we implement the shader.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AuraShaderModule/Private/OutlineShader.cpp</span>

<span class="cp">#include "OutlineShader.h"
</span>
<span class="n">IMPLEMENT_SHADER_TYPE</span><span class="p">(,</span> <span class="n">FAuraShaderPS</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"/AuraShaderModule/Aura.usf"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"AuraMainPS"</span><span class="p">),</span> <span class="n">SF_Pixel</span><span class="p">);</span>
</code></pre></div></div>

<p>Also, don’t forget do add the outline shader we wrote before to the module’s shader directory. It should generally look the same, with some exceptions:</p>

<ol>
  <li>We are using a sampler instead of using <code class="language-plaintext highlighter-rouge">SceneTextureLookup</code></li>
  <li>We need to add some ue5 shader includes</li>
  <li>We need to define <code class="language-plaintext highlighter-rouge">SCREEN_PASS_TEXTURE_VIEWPORT(ViewParams)</code> so we can get variables like the screen’s size.</li>
  <li>We need to define the inputs.</li>
  <li>We need a new function to calculate the UV <code class="language-plaintext highlighter-rouge">float2 PosToUV(float2 Pos)</code></li>
</ol>

<p>In the end it should look something like this</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AuraShaderModule/Shaders/Aura.usf</span>

<span class="cp">#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
</span>
<span class="n">SCREEN_PASS_TEXTURE_VIEWPORT</span><span class="p">(</span><span class="n">ViewParams</span><span class="p">)</span>

<span class="n">SamplerState</span> <span class="n">InputSampler</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">SceneColor</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">SceneDepth</span><span class="p">;</span>
<span class="n">Texture2D</span> <span class="n">Noise</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">LineColor</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">EdgeThickness</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">EdgeIntensity</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">DepthBias</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NoiseSize</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NoiseStrength</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Time</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">MovementSpeed</span><span class="p">;</span>
<span class="n">uint</span> <span class="n">DebugLines</span><span class="p">;</span>

<span class="n">float2</span> <span class="nf">PosToUV</span><span class="p">(</span><span class="n">float2</span> <span class="n">Pos</span><span class="p">);</span>
<span class="kt">float</span> <span class="nf">Edge</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">);</span>
<span class="n">float2</span> <span class="nf">GetMovementDirection</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">);</span>

<span class="n">float4</span> <span class="n">AuraMainPS</span><span class="p">(</span><span class="n">float4</span> <span class="n">SvPosition</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target0</span>
<span class="p">{</span>
    <span class="c1">// Convert screen position to UV coordinates for sampling</span>
    <span class="n">float2</span> <span class="n">ScreenUV</span> <span class="o">=</span> <span class="n">PosToUV</span><span class="p">(</span><span class="n">SvPosition</span><span class="p">).</span><span class="n">xy</span><span class="p">;</span>

    <span class="c1">// Calculate edge intensity</span>
    <span class="kt">float</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">Edge</span><span class="p">(</span><span class="n">ScreenUV</span><span class="p">));</span>

    <span class="c1">// Sample the base scene color at ScreenUV</span>
    <span class="n">float4</span> <span class="n">sceneColor</span> <span class="o">=</span> <span class="n">SceneColor</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="n">InputSampler</span><span class="p">,</span> <span class="n">ScreenUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// Calculate animated noise offset for dynamic effect</span>
    <span class="n">float2</span> <span class="n">noiseMovementVelocity</span> <span class="o">=</span> <span class="n">GetMovementDirection</span><span class="p">(</span><span class="n">ScreenUV</span><span class="p">)</span> <span class="o">*</span> <span class="n">MovementSpeed</span> <span class="o">*</span> <span class="n">Time</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="n">InputSampler</span><span class="p">,</span> <span class="n">ScreenUV</span> <span class="o">*</span> <span class="n">NoiseSize</span> <span class="o">+</span> <span class="n">noiseMovementVelocity</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span>

    <span class="c1">// Debug mode to visualize edges</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DebugLines</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">edge</span> <span class="o">&gt;=</span> <span class="n">DepthBias</span> <span class="o">?</span> <span class="n">edge</span> <span class="o">*</span> <span class="n">LineColor</span> <span class="o">:</span> <span class="n">float4</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">1.</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// Calculate edge color with noise modulation</span>
    <span class="n">float3</span> <span class="n">edgeColor</span> <span class="o">=</span> <span class="n">LineColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">NoiseStrength</span> <span class="o">*</span> <span class="n">edge</span><span class="p">;</span>

    <span class="c1">// Final aura result combining edge color</span>
    <span class="n">float3</span> <span class="n">auraResult</span> <span class="o">=</span> <span class="n">edge</span> <span class="o">&gt;=</span> <span class="n">DepthBias</span> <span class="o">?</span> <span class="n">edgeColor</span> <span class="o">+</span> <span class="n">sceneColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">:</span> <span class="n">sceneColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">auraResult</span><span class="p">,</span> <span class="mf">1.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float2</span> <span class="nf">PosToUV</span><span class="p">(</span><span class="n">float2</span> <span class="n">Pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">ViewportUV</span> <span class="o">=</span> <span class="p">((</span><span class="n">Pos</span> <span class="o">-</span> <span class="n">ViewParams_ViewportMin</span><span class="p">.</span><span class="n">xy</span><span class="p">)</span> <span class="o">*</span> <span class="n">ViewParams_ViewportSizeInverse</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ViewportUV</span> <span class="o">*</span> <span class="n">ViewParams_UVViewportSize</span> <span class="o">+</span> <span class="n">ViewParams_UVViewportMin</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Set direction based on position in the screen space</span>
<span class="n">float2</span> <span class="nf">GetMovementDirection</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">float2</span><span class="p">(</span><span class="n">uv</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">?</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">:</span> <span class="o">-</span><span class="mf">1.</span><span class="n">f</span><span class="p">,</span> <span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">?</span> <span class="mf">1.</span><span class="n">f</span> <span class="o">:</span> <span class="o">-</span><span class="mf">1.</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">Edge</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Set pixel size for edge detection based on viewport size and edge thickness</span>
    <span class="n">float2</span> <span class="n">pixelSize</span> <span class="o">=</span> <span class="n">EdgeThickness</span> <span class="o">/</span> <span class="n">ViewParams_ViewportSize</span><span class="p">;</span>

    <span class="c1">// Define 3x3 matrix for Sobel edge detection</span>
    <span class="n">float2</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span>
    <span class="p">{</span>
        <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">),</span>
        <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">float2</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="n">f</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="c1">// Calculate depth gradients using the Sobel matrix for edge intensity</span>
    <span class="n">float2</span> <span class="n">gradients</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.</span><span class="n">f</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Calculate offset UV once per pixel</span>
        <span class="n">float2</span> <span class="n">offsetUV</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">+</span> <span class="n">float2</span><span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelSize</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixelSize</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="c1">// Depth sample per matrix entry</span>
        <span class="n">gradients</span> <span class="o">+=</span> <span class="n">sobelMatrix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">SceneDepth</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="n">InputSampler</span><span class="p">,</span> <span class="n">offsetUV</span><span class="p">,</span> <span class="mi">0</span><span class="p">).</span><span class="n">r</span><span class="p">;</span> 
    <span class="p">}</span>

    <span class="c1">// Apply edge intensity and return the length of the gradient vector for edge strength</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">gradients</span> <span class="o">*</span> <span class="n">EdgeIntensity</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Once you have all of this, launch UE5 from visual studio to make sure everything compiles.</p>

<h3 id="scene-view-extensions">Scene view extensions</h3>

<p>As I mentioned, the <code class="language-plaintext highlighter-rouge">scene view extension</code> class is what’s responsible for injecting the render pass in the engine. If you look at this base class, you can see all the functions you can use for this</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//SceneViewExtension.h</span>
<span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>
<span class="cm">/**
 * Called on game thread when creating the view.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetupView</span><span class="p">(</span><span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**
* Called when creating the viewpoint, before culling, in case an external tracking device needs to modify the base location of the view
*/</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SetupViewPoint</span><span class="p">(</span><span class="n">APlayerController</span><span class="o">*</span> <span class="n">Player</span><span class="p">,</span> <span class="n">FMinimalViewInfo</span><span class="o">&amp;</span> <span class="n">InViewInfo</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called when creating the view, in case non-stereo devices need to update projection matrix.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">SetupViewProjectionMatrix</span><span class="p">(</span><span class="n">FSceneViewProjectionData</span><span class="o">&amp;</span> <span class="n">InOutProjectionData</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called on game thread when view family is about to be rendered.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">BeginRenderViewFamily</span><span class="p">(</span><span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/**
 * Called on render thread at the start of rendering.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PreRenderViewFamily_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called on render thread at the start of rendering, for each view, after PreRenderViewFamily_RenderThread call.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PreRenderView_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called on render thread prior to initializing views.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PreInitViews_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called on render thread right before Base Pass rendering. bDepthBufferIsPopulated is true if anything has been rendered to the depth buffer. This does not need to be a full depth prepass.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PreRenderBasePass_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">bDepthBufferIsPopulated</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called right after Base Pass rendering finished when using the deferred renderer.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostRenderBasePassDeferred_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">,</span> <span class="k">const</span> <span class="n">FRenderTargetBindingSlots</span><span class="o">&amp;</span> <span class="n">RenderTargets</span><span class="p">,</span> <span class="n">TRDGUniformBufferRef</span><span class="o">&lt;</span><span class="n">FSceneTextureUniformParameters</span><span class="o">&gt;</span> <span class="n">SceneTextures</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**
 * Called right after Base Pass rendering finished when using the mobile renderer.
 */</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PostRenderBasePassMobile_RenderThread</span><span class="p">(</span><span class="n">FRHICommandList</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="p">{}</span>
<span class="o">&lt;</span><span class="p">...</span><span class="o">&gt;</span>

</code></pre></div></div>

<p>In this blog post I will only touch on <code class="language-plaintext highlighter-rouge">virtual void PostRenderBasePass_RenderThread(FRHICommandListImmediate&amp; RHICmdList, FSceneView&amp; InView)</code>, but I highly encourage you to look into this class to check its full capabilities yourself.
Let’s expand on this class to make our own render pass in <code class="language-plaintext highlighter-rouge">CustomViewExtension.h</code></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//AuraShaderModule/Public/CustomViewExtension.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include "SceneViewExtension.h"
</span>
<span class="k">class</span> <span class="nc">CUSTOMMODULE_API</span> <span class="n">FCustomViewExtension</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FSceneViewExtensionBase</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="n">FCustomViewExtension</span><span class="p">(</span><span class="k">const</span> <span class="n">FAutoRegister</span><span class="o">&amp;</span> <span class="n">AutoRegister</span><span class="p">,</span> <span class="n">FLinearColor</span> <span class="n">edgeColor</span><span class="p">,</span> <span class="kt">float</span> <span class="n">depthBias</span><span class="p">,</span> <span class="kt">float</span> <span class="n">edgeThickness</span><span class="p">,</span> <span class="kt">float</span> <span class="n">edgeIntensity</span><span class="p">,</span> <span class="kt">float</span> <span class="n">noiseSize</span><span class="p">,</span> <span class="kt">float</span> <span class="n">noiseStrength</span><span class="p">,</span> <span class="kt">float</span> <span class="n">movementSpeed</span><span class="p">,</span> <span class="n">UTexture2D</span><span class="o">*</span> <span class="n">texture</span><span class="p">);</span>

<span class="c1">//~ Begin FSceneViewExtensionBase Interface</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetupViewFamily</span><span class="p">(</span><span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetupView</span><span class="p">(</span><span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">BeginRenderViewFamily</span><span class="p">(</span><span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PreRenderViewFamily_RenderThread</span><span class="p">(</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">,</span> <span class="n">FSceneViewFamily</span><span class="o">&amp;</span> <span class="n">InViewFamily</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PreRenderView_RenderThread</span><span class="p">(</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PostRenderBasePass_RenderThread</span><span class="p">(</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">,</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">InView</span><span class="p">)</span> <span class="k">override</span> <span class="p">{};</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">PrePostProcessPass_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="k">const</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span> <span class="k">const</span> <span class="n">FPostProcessingInputs</span><span class="o">&amp;</span> <span class="n">Inputs</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="c1">//~ End FSceneViewExtensionBase Interface</span>

<span class="kt">void</span> <span class="n">SetEdgeColor</span><span class="p">(</span><span class="k">const</span> <span class="n">FLinearColor</span><span class="o">&amp;</span> <span class="n">color</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetDepthBias</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">bias</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetEdgeThickness</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">thickness</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetEdgeIntensity</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">intensity</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetSceneDepthSize</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetNoiseSize</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetNoiseStrength</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">strength</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetTime</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">time</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetMovementSpeed</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span> <span class="n">speed</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetDebugLines</span><span class="p">(</span><span class="k">const</span> <span class="kt">bool</span><span class="o">&amp;</span> <span class="n">debug</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">SetNoiseTexture</span><span class="p">(</span><span class="n">UTexture2D</span><span class="o">*</span> <span class="n">tex</span><span class="p">);</span>

<span class="nl">private:</span>
<span class="n">FLinearColor</span> <span class="n">EdgeColor</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">DepthBias</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">EdgeThickness</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">EdgeIntensity</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NoiseSize</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">Time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">MovementSpeed</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">NoiseStrength</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">DebugLines</span><span class="p">;</span>
<span class="n">UTexture2D</span><span class="o">*</span> <span class="n">NoiseTex</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>All we need to do is override the <code class="language-plaintext highlighter-rouge">PostRenderBasePass_RenderThread</code> function and declare all our variables, as well as the setters.
Next, in the .cpp file is were we implement the logic, specifically in <code class="language-plaintext highlighter-rouge">PostRenderBasePass_RenderThread</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="n">FMyViewExtension</span><span class="o">::</span><span class="n">PrePostProcessPass_RenderThread</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="k">const</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span> <span class="k">const</span> <span class="n">FPostProcessingInputs</span><span class="o">&amp;</span> <span class="n">Inputs</span><span class="p">)</span> <span class="p">{</span>

<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">CustomDepthTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">.</span><span class="n">Format</span> <span class="o">!=</span> <span class="n">PF_DepthStencil</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> 

<span class="n">checkSlow</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">bIsViewInfo</span><span class="p">);</span>

<span class="c1">//We check if the texture is valid</span>
<span class="k">if</span> <span class="p">(</span><span class="n">NoiseTex</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

<span class="k">const</span> <span class="n">FIntRect</span> <span class="n">Viewport</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">View</span><span class="p">).</span><span class="n">ViewRect</span><span class="p">;</span>
<span class="n">FScreenPassTexture</span> <span class="n">SceneColor</span><span class="p">((</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SceneColorTexture</span><span class="p">,</span> <span class="n">Viewport</span><span class="p">);</span>
<span class="n">FGlobalShaderMap</span><span class="o">*</span> <span class="n">GlobalShaderMap</span> <span class="o">=</span> <span class="n">GetGlobalShaderMap</span><span class="p">(</span><span class="n">GMaxRHIFeatureLevel</span><span class="p">);</span>

<span class="n">RDG_EVENT_SCOPE</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="s">"Aura Render Pass"</span><span class="p">);</span>

<span class="c1">// Viewport parameters</span>
<span class="k">const</span> <span class="n">FScreenPassTextureViewport</span> <span class="n">SceneColorTextureViewport</span><span class="p">(</span><span class="n">SceneColor</span><span class="p">);</span>
<span class="k">const</span> <span class="n">FScreenPassTextureViewportParameters</span> <span class="n">SceneTextureViewportParams</span> <span class="o">=</span> <span class="n">GetTextureViewportParameters</span><span class="p">(</span><span class="n">SceneColorTextureViewport</span><span class="p">);</span>

<span class="c1">// Render targets</span>
<span class="n">FScreenPassRenderTarget</span> <span class="n">SceneColorCopyRenderTarget</span><span class="p">;</span>
<span class="n">SceneColorCopyRenderTarget</span><span class="p">.</span><span class="n">Texture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">((</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SceneColorTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Scene Color Copy"</span><span class="p">));</span>
<span class="n">FScreenPassRenderTarget</span> <span class="n">UVMaskRenderTarget</span><span class="p">;</span>
<span class="n">UVMaskRenderTarget</span><span class="p">.</span><span class="n">Texture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">CreateTexture</span><span class="p">((</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SceneColorTexture</span><span class="o">-&gt;</span><span class="n">Desc</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"UV Mask"</span><span class="p">));</span>

<span class="c1">//Getting the noise texture</span>
<span class="n">FTextureResource</span><span class="o">*</span> <span class="n">TextureResource</span> <span class="o">=</span> <span class="n">NoiseTex</span><span class="o">-&gt;</span><span class="n">GetResource</span><span class="p">();</span>
<span class="n">FTextureRHIRef</span> <span class="n">TextureRHI</span> <span class="o">=</span> <span class="n">TextureResource</span><span class="o">-&gt;</span><span class="n">TextureRHI</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">noiseTexture</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">RegisterExternalTexture</span><span class="p">(</span><span class="n">CreateRenderTarget</span><span class="p">(</span><span class="n">TextureRHI</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"NoiseTexture"</span><span class="p">)));</span>

<span class="c1">// Shader setup</span>
<span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FAuraShaderPS</span><span class="o">&gt;</span> <span class="n">AuraPixelShader</span><span class="p">(</span><span class="n">GlobalShaderMap</span><span class="p">);</span>
<span class="n">FAuraShaderPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">AuraParameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FAuraShaderPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">SceneColor</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SceneColorTexture</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">SceneDepth</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Inputs</span><span class="p">.</span><span class="n">SceneTextures</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SceneDepthTexture</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;</span><span class="n">SF_Point</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="p">,</span> <span class="n">AM_Wrap</span><span class="o">&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">LineColor</span> <span class="o">=</span> <span class="n">EdgeColor</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">DepthBias</span> <span class="o">=</span> <span class="n">DepthBias</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">EdgeThickness</span> <span class="o">=</span> <span class="n">EdgeThickness</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">EdgeIntensity</span> <span class="o">=</span> <span class="n">EdgeIntensity</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">NoiseSize</span> <span class="o">=</span> <span class="n">NoiseSize</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">NoiseStrength</span> <span class="o">=</span> <span class="n">NoiseStrength</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">MovementSpeed</span> <span class="o">=</span> <span class="n">MovementSpeed</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">Time</span> <span class="o">=</span> <span class="n">Time</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">DebugLines</span> <span class="o">=</span> <span class="n">DebugLines</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">Noise</span> <span class="o">=</span> <span class="n">noiseTexture</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">ViewParams</span> <span class="o">=</span> <span class="n">SceneTextureViewportParams</span><span class="p">;</span>
<span class="n">AuraParameters</span><span class="o">-&gt;</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FRenderTargetBinding</span><span class="p">(</span><span class="n">SceneColor</span><span class="p">.</span><span class="n">Texture</span><span class="p">,</span> <span class="n">ERenderTargetLoadAction</span><span class="o">::</span><span class="n">ELoad</span><span class="p">);</span>

<span class="n">FPixelShaderUtils</span><span class="o">::</span><span class="n">AddFullscreenPass</span><span class="p">(</span>
    <span class="n">GraphBuilder</span><span class="p">,</span>
    <span class="n">GlobalShaderMap</span><span class="p">,</span>
    <span class="n">FRDGEventName</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Aura"</span><span class="p">)),</span>
    <span class="n">AuraPixelShader</span><span class="p">,</span>
    <span class="n">AuraParameters</span><span class="p">,</span>
    <span class="n">Viewport</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is a lot to take in, but all we are doing is</p>

<ol>
  <li>Checking validity of resources</li>
  <li>Getting the viewport parameters</li>
  <li>Getting scene textures and render targets</li>
  <li>Setting the values into an instance of an input struct that we created earlier</li>
  <li>Adding the pass</li>
</ol>

<p>A thing worth noting is <code class="language-plaintext highlighter-rouge">GetTextureViewportParameters(SceneColorTextureViewport)</code>. This is a function I got from a <a href="https://itscai.us/blog/post/ue-view-extensions/">blog post</a> I learned all of this from. I highly recommend giving it a look as well. This is the function.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FScreenPassTextureViewportParameters</span> <span class="nf">GetTextureViewportParameters</span><span class="p">(</span><span class="k">const</span> <span class="n">FScreenPassTextureViewport</span><span class="o">&amp;</span> <span class="n">InViewport</span><span class="p">)</span> <span class="p">{</span>
<span class="k">const</span> <span class="n">FVector2f</span> <span class="n">Extent</span><span class="p">(</span><span class="n">InViewport</span><span class="p">.</span><span class="n">Extent</span><span class="p">);</span>
<span class="k">const</span> <span class="n">FVector2f</span> <span class="n">ViewportMin</span><span class="p">(</span><span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Min</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>
<span class="k">const</span> <span class="n">FVector2f</span> <span class="n">ViewportMax</span><span class="p">(</span><span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Max</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>
<span class="k">const</span> <span class="n">FVector2f</span> <span class="n">ViewportSize</span> <span class="o">=</span> <span class="n">ViewportMax</span> <span class="o">-</span> <span class="n">ViewportMin</span><span class="p">;</span>

<span class="n">FScreenPassTextureViewportParameters</span> <span class="n">Parameters</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">InViewport</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">Extent</span> <span class="o">=</span> <span class="n">FVector2f</span><span class="p">(</span><span class="n">Extent</span><span class="p">);</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">ExtentInverse</span> <span class="o">=</span> <span class="n">FVector2f</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Extent</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Extent</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>

    <span class="n">Parameters</span><span class="p">.</span><span class="n">ScreenPosToViewportScale</span> <span class="o">=</span> <span class="n">FVector2f</span><span class="p">(</span><span class="mf">0.5</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">ViewportSize</span><span class="p">;</span>	
    <span class="n">Parameters</span><span class="p">.</span><span class="n">ScreenPosToViewportBias</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="n">ViewportSize</span><span class="p">)</span> <span class="o">+</span> <span class="n">ViewportMin</span><span class="p">;</span>	

    <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportMin</span> <span class="o">=</span> <span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Min</span><span class="p">;</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportMax</span> <span class="o">=</span> <span class="n">InViewport</span><span class="p">.</span><span class="n">Rect</span><span class="p">.</span><span class="n">Max</span><span class="p">;</span>

    <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportSize</span> <span class="o">=</span> <span class="n">ViewportSize</span><span class="p">;</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportSizeInverse</span> <span class="o">=</span> <span class="n">FVector2f</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportSize</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ViewportSize</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>

    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMin</span> <span class="o">=</span> <span class="n">ViewportMin</span> <span class="o">*</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ExtentInverse</span><span class="p">;</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMax</span> <span class="o">=</span> <span class="n">ViewportMax</span> <span class="o">*</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ExtentInverse</span><span class="p">;</span>

    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportSize</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMax</span> <span class="o">-</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMin</span><span class="p">;</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportSizeInverse</span> <span class="o">=</span> <span class="n">FVector2f</span><span class="p">(</span><span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportSize</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span> <span class="o">/</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportSize</span><span class="p">.</span><span class="n">Y</span><span class="p">);</span>

    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportBilinearMin</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMin</span> <span class="o">+</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ExtentInverse</span><span class="p">;</span>
    <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportBilinearMax</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">UVViewportMax</span> <span class="o">-</span> <span class="mf">0.5</span><span class="n">f</span> <span class="o">*</span> <span class="n">Parameters</span><span class="p">.</span><span class="n">ExtentInverse</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">Parameters</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally we are done setting this up. Now we can move to the very last step.</p>

<h3 id="implementing-the-scene-view-extension">Implementing the scene view extension</h3>

<p>This is the last and most simple step here. All we have to do to start up our render pass is call the SceneViewExtension constructor somewhere in our game. I personally like having it in a blueprint, on BeginPlay(). I recommend you do it as well, to avoid any annoying crashes caused by errors.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">ACustomPass</span><span class="o">::</span><span class="n">BeginPlay</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Super</span><span class="o">::</span><span class="n">BeginPlay</span><span class="p">();</span>
	<span class="n">MyViewExtension</span> <span class="o">=</span> <span class="n">FSceneViewExtensions</span><span class="o">::</span><span class="n">NewExtension</span><span class="o">&lt;</span><span class="n">FMyViewExtension</span><span class="o">&gt;</span><span class="p">(</span><span class="n">EdgeColor</span><span class="p">,</span> <span class="n">DepthBias</span><span class="p">,</span> <span class="n">EdgeThickness</span><span class="p">,</span> <span class="n">EdgeIntensity</span><span class="p">,</span> <span class="n">NoiseSize</span><span class="p">,</span> <span class="n">NoiseStrength</span><span class="p">,</span> <span class="n">NoiseMovementSpeed</span><span class="p">,</span> <span class="n">NoiseTex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Lastly, you can also set all the variables in the tick function, so you can modify them in the editor as well.
Now compile and press play!
<img src="assets/images/Fog+Aura2.gif" alt="alt text" title="Title" /></p>

<p>(For extra effect I also added a very simple fog using the depth stencil ;) )</p>

<h2 id="conclusion">Conclusion</h2>

<p>Through this guide, you should now have a foundational understanding of how to integrate custom shaders into Unreal Engine 5, extending its graphical capabilities with HLSL.</p>

<p>The techniques in this guide were inspired by research and external resources on Unreal Engine’s shader capabilities. The following references were especially helpful:</p>

<ol>
  <li><a href="https://viclw17.github.io/2022/02/01/unreal-engine-custom-node">Unreal Engine Custom Node by 1000 Forms of Bunnies</a></li>
  <li><a href="https://itscai.us/blog/post/ue-view-extensions/">Global shaders in Unreal without engine modification by Caius</a></li>
  <li><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/adding-global-shaders-to-unreal-engine">Unreal Engine’s documentation on global shaders</a></li>
  <li><a href="https://logins.github.io/graphics/2021/03/31/UE4ShadersIntroduction.html">UE4 Shaders Introduction by Riccardo Loggini</a></li>
</ol>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        
        <p class="copyright">Blog post maintained by <a href="https://github.com/KarolinaMot">KarolinaMot</a></p>
        <p class="copyright">Email: karolina.motuzyte02@gmail.com</p>

        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
